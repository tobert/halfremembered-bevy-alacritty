# üî§ Font Rendering Deep Dive

**Generated by:** Claude (claude-sonnet-4-5-20250929)
**Date:** 2025-11-08
**Status:** Technical reference

---

## Overview

High-quality terminal font rendering for the render-to-texture architecture. We prioritize visual quality over resource constraints, using generous VRAM and GPU for crisp, beautiful text.

## Font Selection: Cascadia Mono

**Choice:** Microsoft Cascadia Mono (Regular weight for MVP)

**Why:**
- ‚úÖ Designed specifically for terminals
- ‚úÖ Excellent hinting for pixel grid alignment
- ‚úÖ Clear distinction between similar characters (0/O, 1/l/I)
- ‚úÖ Good Unicode coverage (box-drawing, blocks)
- ‚úÖ Free, open-source (SIL Open Font License)
- ‚úÖ Nerd Font variants available (future: icons)
- ‚úÖ Professional, modern appearance

**Alternatives Considered:**
- JetBrains Mono (good, but Cascadia has better hinting)
- Fira Code (more ligatures, but we're not using them yet)
- Iosevka (very customizable, but Cascadia is simpler)

**Download:**
```bash
# Version 2404.23 or later
https://github.com/microsoft/cascadia-code/releases
```

## Font Rendering Pipeline

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. Load Font                              ‚îÇ
‚îÇ    Cascadia Mono TTF ‚Üí ab_glyph::FontArc  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. Calculate Metrics                      ‚îÇ
‚îÇ    Cell width, cell height, baseline      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 3. Generate Atlas                         ‚îÇ
‚îÇ    Rasterize glyphs ‚Üí 4096x4096 texture   ‚îÇ
‚îÇ    ASCII + box-drawing + blocks           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 4. Build UV Map                           ‚îÇ
‚îÇ    char ‚Üí (x, y, w, h) in atlas           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 5. Blit to Terminal Texture               ‚îÇ
‚îÇ    Lookup UV, apply colors, copy pixels   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Font Metrics Calculation

**Critical for alignment:** All glyphs must fit in exact grid cells.

```rust
use ab_glyph::{FontArc, PxScale, ScaleFont};

pub struct FontMetrics {
    pub font: FontArc,
    pub scale: PxScale,
    pub cell_width: f32,
    pub cell_height: f32,
    pub baseline_offset: f32,
}

impl FontMetrics {
    pub fn calculate(font: FontArc, font_size: f32) -> Self {
        let scale = PxScale::from(font_size);
        let scaled_font = font.as_scaled(scale);

        // Cell width: use 'M' (widest monospace char)
        let m_glyph = font.glyph_id('M').with_scale(scale);
        let cell_width = scaled_font.h_advance(m_glyph.id);

        // Cell height: ascent + descent + line gap
        let v_metrics = scaled_font.v_metrics();
        let cell_height = v_metrics.ascent - v_metrics.descent + v_metrics.line_gap;

        // Baseline: from top of cell
        let baseline_offset = v_metrics.ascent;

        Self {
            font,
            scale,
            cell_width,
            cell_height: cell_height.ceil(),  // Round up for clean grid
            baseline_offset,
        }
    }
}
```

**Hardcoded for MVP:**
- Font size: 14pt
- Expected metrics: ~9px width, ~20px height (depends on DPI)

## Glyph Atlas Generation

**Atlas Size:** 4096x4096 pixels (quality > memory)

**Character Sets to Pre-render:**

1. **ASCII Printable (32-126):** 95 chars
   ```
   !"#$%&'()*+,-./0123456789:;<=>?
   @ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_
   `abcdefghijklmnopqrstuvwxyz{|}~
   ```

2. **Box-Drawing (U+2500-257F):** 128 chars
   ```
   ‚îÄ‚îÇ‚îå‚îê‚îî‚îò‚îú‚î§‚î¨‚î¥‚îº‚ïê‚ïë‚ïî‚ïó‚ïö‚ïù‚ï†‚ï£‚ï¶‚ï©‚ï¨
   ... (full Unicode block)
   ```

3. **Block Elements (U+2580-259F):** 32 chars
   ```
   ‚ñÄ‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá‚ñà‚ñâ‚ñä‚ñã‚ñå‚ñç‚ñé‚ñè
   ‚ñê‚ñë‚ñí‚ñì‚ñî‚ñï‚ññ‚ñó‚ñò‚ñô‚ñö‚ñõ‚ñú‚ñù‚ñû‚ñü
   ```

**Total:** ~255 pre-rendered glyphs in atlas

**Layout Strategy:**
- Grid arrangement (glyphs per row = atlas_width / cell_width)
- Row-major order (left-to-right, top-to-bottom)
- Leave space for dynamic glyphs (extended Unicode)

```rust
pub struct GlyphAtlas {
    pub texture_data: Vec<u8>,  // RGBA8
    pub atlas_width: u32,       // 4096
    pub atlas_height: u32,      // 4096
    pub uv_map: HashMap<char, Rect>,
    pub cell_width: u32,
    pub cell_height: u32,
}

impl GlyphAtlas {
    pub fn generate(metrics: &FontMetrics) -> Result<Self> {
        let atlas_width = 4096;
        let atlas_height = 4096;

        let cell_w = metrics.cell_width.ceil() as u32;
        let cell_h = metrics.cell_height.ceil() as u32;

        let cols_per_row = atlas_width / cell_w;  // ~455 glyphs per row

        // Initialize with transparent black
        let mut texture_data = vec![0u8; (atlas_width * atlas_height * 4) as usize];

        let chars_to_render = get_chars_to_render();
        let mut uv_map = HashMap::with_capacity(chars_to_render.len());

        for (i, &ch) in chars_to_render.iter().enumerate() {
            let col = (i as u32) % cols_per_row;
            let row = (i as u32) / cols_per_row;

            let x = col * cell_w;
            let y = row * cell_h;

            // Rasterize glyph into atlas
            rasterize_glyph_to_atlas(
                &metrics.font,
                ch,
                metrics.scale,
                metrics.baseline_offset,
                &mut texture_data,
                atlas_width,
                x,
                y,
                cell_w,
                cell_h,
            );

            // Store UV coordinates (normalized 0.0-1.0)
            let uv = Rect {
                min: Vec2::new(
                    x as f32 / atlas_width as f32,
                    y as f32 / atlas_height as f32,
                ),
                max: Vec2::new(
                    (x + cell_w) as f32 / atlas_width as f32,
                    (y + cell_h) as f32 / atlas_height as f32,
                ),
            };
            uv_map.insert(ch, uv);
        }

        Ok(Self {
            texture_data,
            atlas_width,
            atlas_height,
            uv_map,
            cell_width: cell_w,
            cell_height: cell_h,
        })
    }
}

fn get_chars_to_render() -> Vec<char> {
    let mut chars = Vec::new();

    // ASCII printable
    chars.extend(32u8..=126u8.map(|b| b as char));

    // Box-drawing
    chars.extend(0x2500u32..=0x257Fu32.filter_map(char::from_u32));

    // Block elements
    chars.extend(0x2580u32..=0x259Fu32.filter_map(char::from_u32));

    chars
}
```

## Glyph Rasterization

**Using ab_glyph for quality:**

```rust
use ab_glyph::{FontArc, PxScale, Glyph, point};

fn rasterize_glyph_to_atlas(
    font: &FontArc,
    ch: char,
    scale: PxScale,
    baseline_offset: f32,
    atlas_data: &mut [u8],
    atlas_width: u32,
    x: u32,
    y: u32,
    cell_w: u32,
    cell_h: u32,
) {
    let glyph_id = font.glyph_id(ch);
    let glyph = glyph_id.with_scale(scale);

    // Position glyph in cell (centered horizontally, baseline-aligned vertically)
    let h_advance = font.h_advance(glyph.id);
    let x_offset = ((cell_w as f32 - h_advance) / 2.0).max(0.0);

    let positioned = glyph.into_outline_glyph(point(
        x as f32 + x_offset,
        y as f32 + baseline_offset,
    ));

    if let Some(outlined) = positioned {
        outlined.draw(|px, py, coverage| {
            let atlas_x = x + px;
            let atlas_y = y + py;

            if atlas_x >= atlas_width || atlas_y >= atlas_width {
                return;  // Out of bounds
            }

            let idx = ((atlas_y * atlas_width + atlas_x) * 4) as usize;

            // Grayscale anti-aliasing
            let alpha = (coverage * 255.0) as u8;
            atlas_data[idx] = 255;      // R
            atlas_data[idx + 1] = 255;  // G
            atlas_data[idx + 2] = 255;  // B
            atlas_data[idx + 3] = alpha;// A (coverage)
        });
    }
}
```

**Rendering Quality Settings:**
- **Anti-aliasing:** Grayscale (no subpixel AA for cleaner scaling)
- **Hinting:** FreeType auto-hinting (enabled by default in ab_glyph)
- **Positioning:** Subpixel positioning disabled (snap to pixel grid)
- **Gamma:** Linear space (sRGB conversion in shader if needed)

## Terminal Texture Blitting

**For each cell:** Copy glyph from atlas, apply colors.

```rust
fn blit_glyph_to_terminal(
    terminal_data: &mut [u8],
    atlas_data: &[u8],
    atlas_width: u32,
    terminal_width: u32,
    dest_x: u32,
    dest_y: u32,
    cell_w: u32,
    cell_h: u32,
    uv: &Rect,
    fg_color: Color,
    bg_color: Color,
) {
    // Convert UV to atlas pixel coordinates
    let src_x = (uv.min.x * atlas_width as f32) as u32;
    let src_y = (uv.min.y * atlas_width as f32) as u32;

    let fg = color_to_rgba(fg_color);
    let bg = color_to_rgba(bg_color);

    for py in 0..cell_h {
        for px in 0..cell_w {
            let atlas_idx = ((src_y + py) * atlas_width + (src_x + px)) * 4;
            let term_idx = ((dest_y + py) * terminal_width + (dest_x + px)) * 4;

            let alpha = atlas_data[atlas_idx + 3] as f32 / 255.0;

            // Alpha blend: fg over bg
            terminal_data[term_idx] = ((fg.0 as f32 * alpha) + (bg.0 as f32 * (1.0 - alpha))) as u8;
            terminal_data[term_idx + 1] = ((fg.1 as f32 * alpha) + (bg.1 as f32 * (1.0 - alpha))) as u8;
            terminal_data[term_idx + 2] = ((fg.2 as f32 * alpha) + (bg.2 as f32 * (1.0 - alpha))) as u8;
            terminal_data[term_idx + 3] = 255;  // Fully opaque
        }
    }
}

fn color_to_rgba(color: Color) -> (u8, u8, u8, u8) {
    let srgba = color.to_srgba();
    (
        (srgba.red * 255.0) as u8,
        (srgba.green * 255.0) as u8,
        (srgba.blue * 255.0) as u8,
        (srgba.alpha * 255.0) as u8,
    )
}
```

## Performance Optimizations

### 1. Pre-rendered Atlas
- **Benefit:** Glyph rasterization happens once at startup
- **Cost:** 4096√ó4096√ó4 = 64 MB VRAM (acceptable)

### 2. Dirty Region Tracking
```rust
#[derive(Default)]
pub struct DirtyRegions {
    pub regions: Vec<Rect>,
}

impl DirtyRegions {
    pub fn mark_cell(&mut self, col: u32, row: u32, cell_w: u32, cell_h: u32) {
        self.regions.push(Rect {
            min: Vec2::new((col * cell_w) as f32, (row * cell_h) as f32),
            max: Vec2::new(((col + 1) * cell_w) as f32, ((row + 1) * cell_h) as f32),
        });
    }

    pub fn merge(&mut self) {
        // TODO: Merge overlapping regions for efficiency
    }

    pub fn clear(&mut self) {
        self.regions.clear();
    }
}
```

### 3. Incremental Updates
- Only blit changed cells
- Upload only dirty regions to GPU
- Target: < 1ms per frame for typical updates

### 4. Atlas Caching
- Keep atlas in VRAM permanently
- No per-frame uploads for atlas
- Terminal texture uploads only

## Color Handling

**Tokyo Night Colors (Hardcoded):**

```rust
pub fn map_ansi_color(index: u8, bright: bool, colors: &TokyoNightColors) -> Color {
    match (index, bright) {
        (0, false) => colors.black,
        (0, true) => colors.bright_black,
        (1, false) => colors.red,
        (1, true) => colors.bright_red,
        (2, false) => colors.green,
        (2, true) => colors.bright_green,
        (3, false) => colors.yellow,
        (3, true) => colors.bright_yellow,
        (4, false) => colors.blue,
        (4, true) => colors.bright_blue,
        (5, false) => colors.magenta,
        (5, true) => colors.bright_magenta,
        (6, false) => colors.cyan,
        (6, true) => colors.bright_cyan,
        (7, false) => colors.white,
        (7, true) => colors.bright_white,
        _ => colors.foreground,
    }
}
```

**Future: 256-color + truecolor support**

## Text Effects

**MVP: Basic attributes**
- ‚úÖ Foreground color
- ‚úÖ Background color
- ‚è≥ Bold (future: use Bold font variant)
- ‚è≥ Italic (future: use Italic font variant)
- ‚è≥ Underline (future: draw line below glyph)

**Post-MVP:**
- Dim (reduce opacity)
- Strikethrough
- Blink (CSS-style animation)
- Reverse video

## Quality Checklist

- [ ] Glyphs are crisp at default size
- [ ] No bleeding between cells
- [ ] Box-drawing characters connect perfectly
- [ ] Baseline alignment consistent
- [ ] Colors accurate (sRGB)
- [ ] Text readable when scaled tiny (0.05)
- [ ] Text readable when fullscreen
- [ ] No visible artifacts or aliasing

## Future Enhancements

### Font Ligatures
- Requires `rustybuzz` for text shaping
- Detect sequences like `=>`, `!=`, `->>`
- Render as single glyph spanning multiple cells
- Design now, implement post-MVP

### Color Emoji
- Load emoji font (Noto Color Emoji)
- Handle COLR/CPAL tables
- Render emoji as textures
- Wide character support (2-cell width)

### Dynamic Font Sizing
- Regenerate atlas on size change
- Or: Multiple atlases at different sizes
- Smooth interpolation between sizes

---

**Summary:** High-quality font rendering using generous resources. Pre-rendered atlas for speed. Crisp, beautiful text that looks great at any scale.
