# ğŸ§ª Testing & Validation Strategy

**Generated by:** Claude (claude-sonnet-4-5-20250929)
**Date:** 2025-11-08
**Status:** Testing guide

---

## Testing Philosophy

**For MVP:**
- Manual testing with visual verification
- Integration tests for critical paths
- Minimal unit tests (focus on correctness)

**Post-MVP:**
- Comprehensive unit tests
- Automated visual regression tests
- Performance benchmarks

**Rationale:** Get working code first, add tests as we refactor.

## Testing Pyramid

```
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚   Manual    â”‚  â† Visual verification
           â”‚  End-to-End â”‚     Live demo testing
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚  Integration  â”‚  â† PTY + Term + Render
          â”‚     Tests     â”‚     Critical workflows
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚    Unit Tests       â”‚  â† Font metrics
        â”‚  (Selected modules) â”‚     Color mapping
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Manual Testing Checklist

### Phase 1: Terminal Backend

**PTY Tests:**
- [ ] PTY spawns successfully on Linux
- [ ] PTY spawns successfully on Windows
- [ ] PTY spawns successfully on macOS
- [ ] Can spawn different shells (bash, zsh, fish)
- [ ] Shell prompt appears
- [ ] Process continues running after spawn

**Terminal Grid Tests:**
- [ ] Grid initializes with correct dimensions (120Ã—30)
- [ ] Grid updates when PTY sends data
- [ ] ANSI colors parsed correctly
- [ ] Box-drawing characters display correctly
- [ ] Cursor position tracked accurately

**Input Tests:**
- [ ] Typing letters works (a-z, A-Z)
- [ ] Numbers and symbols work
- [ ] Enter key sends newline
- [ ] Backspace works
- [ ] Arrow keys send correct sequences
- [ ] Ctrl+C interrupts process
- [ ] Tab completion works in shell

**Interactive Commands:**
```bash
# Run these in the terminal and verify output
ls -la
echo "Hello, terminal!"
cat /etc/hostname
top  # Then 'q' to quit
nvim test.txt  # Then :q to quit
```

### Phase 2: Font System

**Font Loading:**
- [ ] Cascadia Mono loads without errors
- [ ] Font metrics calculated correctly
- [ ] Cell width/height are reasonable (~9Ã—20 px)

**Atlas Generation:**
- [ ] Atlas texture created (4096Ã—4096)
- [ ] All ASCII characters present
- [ ] Box-drawing characters present
- [ ] Block elements present
- [ ] UV map contains all pre-rendered glyphs

**Visual Inspection:**
- [ ] Display atlas as sprite - all glyphs visible
- [ ] Glyphs are crisp and clear
- [ ] No blurriness or artifacts
- [ ] Characters properly aligned in grid

### Phase 3: Render-to-Texture

**Texture Tests:**
- [ ] Terminal texture created successfully
- [ ] Texture dimensions correct (width, height)
- [ ] Handle<Image> exposed via resource
- [ ] Texture can be used as sprite

**Rendering Quality:**
- [ ] Shell prompt renders correctly
- [ ] Colors match Tokyo Night theme
- [ ] Text is crisp and readable
- [ ] Box-drawing lines connect perfectly
- [ ] Background color fills cells
- [ ] Foreground color on glyphs

**Update Tests:**
- [ ] Texture updates when typing
- [ ] Texture updates when command outputs
- [ ] Updates happen in real-time (< 16ms)
- [ ] No flickering or tearing

**Scale Tests:**
- [ ] Texture readable at scale 1.0 (fullscreen)
- [ ] Texture readable at scale 0.1
- [ ] Texture readable at scale 0.05 (tiny CRT)
- [ ] No visual artifacts when scaled

### Phase 4: Game Integration

**CRT Character:**
- [ ] Claude character spawns with terminal texture
- [ ] Terminal visible on tiny sprite (0.05 scale)
- [ ] Can see shell prompt even when tiny
- [ ] Sprite positioned correctly in world

**Zoom Interaction:**
- [ ] Press 'E' near character zooms in
- [ ] Smooth scale transition (0.05 â†’ 1.0)
- [ ] Terminal becomes fullscreen
- [ ] Input routing enables when zoomed
- [ ] ESC zooms back out
- [ ] Smooth transition back (1.0 â†’ 0.05)

**State Persistence:**
- [ ] Terminal keeps running when zoomed out
- [ ] Command output continues in background
- [ ] Zoom back in shows latest state
- [ ] History preserved across zoom cycles

**Live Demo Scenarios:**
```bash
# Start command that outputs continuously
$ ping 8.8.8.8

# Zoom out (should keep pinging)
# Walk around game world
# Zoom back in (should see continued ping output)
```

## Automated Tests

### Unit Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn font_metrics_calculates_reasonable_dimensions() {
        let font_bytes = include_bytes!("../assets/fonts/CascadiaMono-Regular.ttf");
        let metrics = FontMetrics::load(font_bytes, 14.0).unwrap();

        assert!(metrics.cell_width > 5.0 && metrics.cell_width < 15.0);
        assert!(metrics.cell_height > 10.0 && metrics.cell_height < 30.0);
    }

    #[test]
    fn color_mapping_matches_tokyo_night() {
        let colors = TokyoNightColors::default();
        let red = map_ansi_color(1, false, &colors);

        assert_eq!(red, Color::srgb_u8(0xf7, 0x76, 0x8e));
    }

    #[test]
    fn atlas_contains_all_ascii() {
        let chars = get_chars_to_render();

        for ch in 32u8..=126u8 {
            assert!(chars.contains(&(ch as char)));
        }
    }
}
```

### Integration Tests

```rust
#[test]
fn terminal_initialization_flow() {
    let mut app = App::new();
    app.add_plugins(MinimalPlugins)
       .add_plugins(TerminalPlugin);

    app.update();

    // Verify resources exist
    assert!(app.world().get_resource::<PtyResource>().is_some());
    assert!(app.world().get_resource::<TerminalState>().is_some());
    assert!(app.world().get_resource::<TerminalTexture>().is_some());
}

#[test]
fn pty_spawns_and_receives_data() {
    // Spawn PTY with 'echo hello' command
    // Read output
    // Verify "hello" appears in terminal grid

    // This is a complex integration test - implement carefully
}
```

## Performance Testing

### Metrics to Track

1. **Frame Time:**
   - Target: < 16ms (60 FPS)
   - Measure: Bevy diagnostic plugin
   - Test with: Continuous terminal output (`cat large_file.txt`)

2. **Texture Upload Time:**
   - Target: < 5ms per frame
   - Measure: Custom timer around texture update
   - Optimize: Dirty region tracking

3. **PTY Poll Time:**
   - Target: < 1ms per frame
   - Measure: Time spent in `poll_pty` system
   - Test with: High-throughput commands

4. **Startup Time:**
   - Target: < 2 seconds to interactive
   - Measure: Time from launch to first frame
   - Includes: Font load, atlas generation, PTY spawn

### Performance Test Commands

```bash
# High-volume output
$ yes | head -n 10000

# Complex rendering (colors, formatting)
$ ls -lah --color=always /usr/bin

# Continuous updates
$ while true; do date; sleep 0.1; done

# Scrolling performance
$ cat /var/log/syslog  # or similar large file
```

## Visual Regression Testing (Future)

**Tools:**
- Screenshot comparison with `bevy_screenshot` plugin
- Hash-based diff detection
- Golden image repository

**Process:**
1. Render known terminal state
2. Take screenshot
3. Compare to golden image
4. Flag differences

## Platform-Specific Testing

### Linux
- [ ] X11 backend works
- [ ] Wayland backend works
- [ ] Font rendering quality acceptable
- [ ] PTY spawns successfully
- [ ] Terminal works in Ubuntu 22.04+
- [ ] Terminal works in Arch Linux

### Windows
- [ ] ConPTY initializes
- [ ] PowerShell works as shell
- [ ] cmd.exe works as shell
- [ ] Font rendering uses ClearType
- [ ] Terminal works in Windows 10+
- [ ] Terminal works in Windows 11

### macOS
- [ ] Core Text font rendering
- [ ] PTY spawns successfully
- [ ] Terminal works in macOS 12+
- [ ] Retina display scaling

## Edge Cases & Error Handling

### PTY Errors
- [ ] Handle shell not found gracefully
- [ ] Handle PTY creation failure
- [ ] Handle process exit (shell closed)
- [ ] Handle broken pipe on write

### Font Errors
- [ ] Handle font file missing
- [ ] Handle corrupted font file
- [ ] Handle unsupported font format
- [ ] Fallback to system font?

### Rendering Errors
- [ ] Handle missing glyph (fallback to â–¯)
- [ ] Handle texture creation failure
- [ ] Handle GPU out of memory

### Input Edge Cases
- [ ] Rapid key presses
- [ ] Key held down (repeat)
- [ ] Special characters (non-ASCII)
- [ ] Modifier keys (Ctrl, Alt, Shift)
- [ ] Keyboard layout differences

## Debugging Tools

### Debug Views

```rust
// Show atlas texture
fn debug_show_atlas(atlas: Res<GlyphAtlas>, ...) { }

// Show terminal texture
fn debug_show_terminal(term_tex: Res<TerminalTexture>, ...) { }

// Print grid contents
fn debug_print_grid(term: Res<TerminalState>) {
    for row in term.term.grid().display_iter() {
        for cell in row {
            print!("{}", cell.c);
        }
        println!();
    }
}

// Log frame times
fn debug_frame_time(time: Res<Time>) {
    info!("Frame time: {:?}", time.delta());
}
```

### Logging Levels

```bash
# Enable debug logging
RUST_LOG=bevy_terminal=debug cargo run --example claude_crt

# Trace level for detailed PTY I/O
RUST_LOG=bevy_terminal::pty=trace cargo run
```

## Test Execution

### Before Each Commit
```bash
cargo fmt --check
cargo clippy --all-targets -- -D warnings
cargo test
```

### Before Each Push
```bash
cargo build --release
cargo run --example claude_crt  # Manual smoke test
# Test on target platforms (CI handles this)
```

### Before Demo/Release
- [ ] Full manual testing checklist
- [ ] All automated tests pass
- [ ] Performance metrics within targets
- [ ] No known crashes or errors
- [ ] Documentation updated

## Known Issues / Limitations (MVP)

Document these clearly:
- [ ] No scrollback buffer
- [ ] No copy/paste
- [ ] No mouse support
- [ ] No font ligatures
- [ ] No emoji support
- [ ] Single terminal only
- [ ] Hardcoded configuration

## Success Criteria

**MVP is ready when:**
1. âœ… All manual tests pass
2. âœ… Critical integration tests pass
3. âœ… Performance targets met
4. âœ… No crashes in normal usage
5. âœ… Works on Linux, Windows, macOS
6. âœ… Live demo scenario works smoothly
7. âœ… Documentation complete

---

**Testing is iterative.** Start simple, add tests as code matures. Focus on correctness first, performance second, edge cases third.
