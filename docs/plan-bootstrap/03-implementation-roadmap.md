# üó∫Ô∏è Implementation Roadmap

**Generated by:** Claude (claude-sonnet-4-5-20250929)
**Date:** 2025-11-08
**Status:** Phase-by-phase guide

---

## Overview

Four phases from project setup to working demo:
1. **Phase 0:** Project infrastructure
2. **Phase 1:** Terminal backend (PTY + alacritty_terminal)
3. **Phase 2:** Font system and glyph atlas
4. **Phase 3:** Render-to-texture
5. **Phase 4:** Game integration (CRT character demo)

Each phase builds on previous, with working code at every step.

---

## Phase 0: Project Setup

**Goal:** Buildable Cargo workspace with dependencies

### Tasks
- [ ] Create workspace structure
- [ ] Write Cargo.toml files (workspace, plugin, example)
- [ ] Create source file skeletons
- [ ] Download Cascadia Mono fonts
- [ ] Configure rustfmt, clippy, CI
- [ ] Verify `cargo build` succeeds

### Success Criteria
```bash
cargo build          # ‚úÖ Compiles
cargo clippy         # ‚úÖ No warnings
cargo test           # ‚úÖ Runs (0 tests)
cargo run --example claude_crt  # ‚úÖ Opens window
```

### Deliverables
- Working Cargo workspace
- Empty plugin that registers with Bevy
- Example that opens window with placeholder text

### Jujutsu Change
```
chore: Initialize Cargo workspace and project structure

Why: Bootstrap project with render-to-texture architecture
Approach: Workspace setup, font download, CI configuration
Status: Complete - builds and runs

Co-authored-by: Claude <claude@anthropic.com>
```

---

## Phase 1: Terminal Backend

**Goal:** Spawn persistent PTY, integrate alacritty_terminal

### Tasks

#### 1.1: PTY Spawning
- [ ] Implement `pty::spawn_pty()` function
- [ ] Create PTY in Startup system (persistent)
- [ ] Spawn bash (or default shell)
- [ ] Store PTY handles in resource
- [ ] Add error handling with anyhow

**Code Location:** `bevy-terminal/src/pty.rs`

```rust
#[derive(Resource)]
pub struct PtyResource {
    pub reader: Box<dyn Read + Send>,
    pub writer: Box<dyn Write + Send>,
    pub child: Box<dyn Child + Send + Sync>,
}

fn spawn_pty(mut commands: Commands) -> Result<()> {
    // Create PTY with hardcoded size
    let pty_system = native_pty_system();
    let pair = pty_system.openpty(PtySize {
        rows: 30,
        cols: 120,
        pixel_width: 0,
        pixel_height: 0,
    })?;

    let cmd = CommandBuilder::new("bash");
    let child = pair.slave.spawn_command(cmd)?;

    let reader = pair.master.try_clone_reader()?;
    let writer = pair.master.take_writer()?;

    commands.insert_resource(PtyResource {
        reader: Box::new(reader),
        writer: Box::new(writer),
        child,
    });

    info!("‚úÖ PTY spawned");
    Ok(())
}
```

#### 1.2: Terminal State
- [ ] Integrate `alacritty_terminal::Term`
- [ ] Store in resource
- [ ] Initialize with hardcoded config

**Code Location:** `bevy-terminal/src/terminal.rs`

```rust
#[derive(Resource)]
pub struct TerminalState {
    pub term: Term<EventProxy>,
    pub size: TermSize,
}

impl TerminalState {
    pub fn new() -> Self {
        let size = TermSize::new(120, 30);
        let config = Config::default();
        let term = Term::new(config, &size, EventProxy);

        Self { term, size }
    }
}
```

#### 1.3: PTY Polling
- [ ] Implement Update system to poll PTY
- [ ] Read bytes from PTY (non-blocking)
- [ ] Feed bytes to `Term`
- [ ] Handle grid updates

**Code Location:** `bevy-terminal/src/pty.rs`

```rust
fn poll_pty(
    mut pty: ResMut<PtyResource>,
    mut term_state: ResMut<TerminalState>,
) {
    let mut buf = [0u8; 4096];

    match pty.reader.read(&mut buf) {
        Ok(n) if n > 0 => {
            // Feed bytes to terminal
            for &byte in &buf[..n] {
                term_state.term.process(byte);
            }
        }
        Ok(_) => {}  // No data
        Err(e) if e.kind() == io::ErrorKind::WouldBlock => {}
        Err(e) => error!("PTY read error: {}", e),
    }
}
```

#### 1.4: Input Handling
- [ ] Capture keyboard events
- [ ] Convert to bytes (ASCII + ANSI sequences)
- [ ] Write to PTY

**Code Location:** `bevy-terminal/src/input.rs`

```rust
fn handle_input(
    keyboard: Res<ButtonInput<KeyCode>>,
    mut pty: ResMut<PtyResource>,
) {
    for key in keyboard.get_just_pressed() {
        if let Some(bytes) = key_to_bytes(*key) {
            let _ = pty.writer.write_all(&bytes);
            let _ = pty.writer.flush();
        }
    }
}

fn key_to_bytes(key: KeyCode) -> Option<Vec<u8>> {
    match key {
        KeyCode::KeyA => Some(vec![b'a']),
        KeyCode::Enter => Some(vec![b'\r']),
        KeyCode::ArrowUp => Some(b"\x1b[A".to_vec()),
        // TODO: Complete mapping
        _ => None,
    }
}
```

### Success Criteria
- PTY spawns at startup
- Terminal grid updates when PTY sends data
- Keyboard input writes to PTY
- Can see shell prompt in debug logs
- `info!("Grid content: {:?}", term.grid())`

### Testing
```bash
# Run example, type commands
cargo run --example claude_crt

# Should see in logs:
# "PTY spawned"
# "Received N bytes from PTY"
# "Grid updated"
```

### Jujutsu Change
```
feat: Implement persistent PTY and terminal state

Why: Core terminal backend for render-to-texture plugin
Approach:
- PTY spawned in Startup system (persistent lifecycle)
- alacritty_terminal::Term for grid management
- Continuous polling in Update system
- Keyboard ‚Üí PTY input handling

Status: Complete - PTY runs, grid updates, input works

Co-authored-by: Claude <claude@anthropic.com>
```

---

## Phase 2: Font System & Glyph Atlas

**Goal:** Load font, generate high-quality glyph atlas

### Tasks

#### 2.1: Font Loading
- [ ] Load Cascadia Mono from assets
- [ ] Parse with ab_glyph
- [ ] Calculate font metrics (cell dimensions)

**Code Location:** `bevy-terminal/src/font.rs`

```rust
#[derive(Resource)]
pub struct FontMetrics {
    pub font: FontArc,
    pub cell_width: f32,
    pub cell_height: f32,
    pub scale: PxScale,
}

impl FontMetrics {
    pub fn load(font_bytes: &[u8], font_size: f32) -> Result<Self> {
        let font = FontArc::try_from_slice(font_bytes)?;
        let scale = PxScale::from(font_size);

        // Calculate cell dimensions
        let glyph = font.glyph_id('M').with_scale(scale);
        let cell_width = font.h_advance(glyph.id);

        let v_metrics = font.height(scale);
        let cell_height = v_metrics.ascent - v_metrics.descent;

        Ok(Self {
            font,
            cell_width,
            cell_height,
            scale,
        })
    }
}
```

#### 2.2: Glyph Atlas Generation
- [ ] Create 4096x4096 texture (or larger)
- [ ] Pre-render ASCII (32-126)
- [ ] Pre-render box-drawing (U+2500-257F)
- [ ] Pre-render block elements (U+2580-259F)
- [ ] Build UV coordinate map

**Code Location:** `bevy-terminal/src/atlas.rs`

```rust
#[derive(Resource)]
pub struct GlyphAtlas {
    pub texture_data: Vec<u8>,  // RGBA pixels
    pub atlas_width: u32,
    pub atlas_height: u32,
    pub uv_map: HashMap<char, Rect>,  // char ‚Üí UV coords
    pub cell_width: u32,
    pub cell_height: u32,
}

impl GlyphAtlas {
    pub fn generate(
        font_metrics: &FontMetrics,
        chars: &[char],
    ) -> Result<Self> {
        let atlas_width = 4096;
        let atlas_height = 4096;
        let mut texture_data = vec![0u8; (atlas_width * atlas_height * 4) as usize];

        let cell_w = font_metrics.cell_width.ceil() as u32;
        let cell_h = font_metrics.cell_height.ceil() as u32;

        let mut uv_map = HashMap::new();
        let cols_per_row = atlas_width / cell_w;

        for (i, &ch) in chars.iter().enumerate() {
            let col = (i as u32) % cols_per_row;
            let row = (i as u32) / cols_per_row;

            let x = col * cell_w;
            let y = row * cell_h;

            // Rasterize glyph
            rasterize_glyph(
                &font_metrics.font,
                ch,
                font_metrics.scale,
                &mut texture_data,
                atlas_width,
                x,
                y,
                cell_w,
                cell_h,
            );

            // Store UV coords
            let uv = Rect {
                min: Vec2::new(x as f32 / atlas_width as f32, y as f32 / atlas_height as f32),
                max: Vec2::new((x + cell_w) as f32 / atlas_width as f32, (y + cell_h) as f32 / atlas_height as f32),
            };
            uv_map.insert(ch, uv);
        }

        Ok(Self {
            texture_data,
            atlas_width,
            atlas_height,
            uv_map,
            cell_width: cell_w,
            cell_height: cell_h,
        })
    }
}
```

#### 2.3: Static Rendering Test
- [ ] Create test texture showing entire atlas
- [ ] Display as sprite
- [ ] Verify glyphs are crisp and aligned

### Success Criteria
- Font loads successfully
- Atlas texture generated (4096x4096)
- All ASCII characters rendered clearly
- Box-drawing characters aligned perfectly
- Test sprite shows atlas contents

### Testing
```bash
# Add test system to example
fn debug_show_atlas(
    atlas: Res<GlyphAtlas>,
    mut commands: Commands,
    mut images: ResMut<Assets<Image>>,
) {
    let image = Image::new(
        Extent3d {
            width: atlas.atlas_width,
            height: atlas.atlas_height,
            depth_or_array_layers: 1,
        },
        TextureDimension::D2,
        atlas.texture_data.clone(),
        TextureFormat::Rgba8UnormSrgb,
    );
    let handle = images.add(image);

    commands.spawn(Sprite::from_image(handle));
}
```

### Jujutsu Change
```
feat: Implement high-quality font loading and glyph atlas

Why: Foundation for render-to-texture terminal rendering
Approach:
- ab_glyph for font rasterization
- 4096x4096 atlas for quality (VRAM not a concern)
- Pre-render ASCII + box-drawing + blocks
- UV map for fast glyph lookup

Status: Complete - atlas renders crisp glyphs

Co-authored-by: Claude <claude@anthropic.com>
```

---

## Phase 3: Render-to-Texture

**Goal:** Render terminal grid to Image texture

### Tasks

#### 3.1: Terminal Texture Resource
- [ ] Create `TerminalTexture` resource
- [ ] Initialize Image with correct dimensions
- [ ] Add to Bevy's Assets<Image>
- [ ] Store Handle<Image>

**Code Location:** `bevy-terminal/src/renderer.rs`

```rust
#[derive(Resource)]
pub struct TerminalTexture {
    pub handle: Handle<Image>,
    pub width: u32,
    pub height: u32,
}

fn init_terminal_texture(
    mut commands: Commands,
    mut images: ResMut<Assets<Image>>,
    atlas: Res<GlyphAtlas>,
    term_state: Res<TerminalState>,
) {
    let width = atlas.cell_width * term_state.size.cols as u32;
    let height = atlas.cell_height * term_state.size.rows as u32;

    let image = Image::new_fill(
        Extent3d {
            width,
            height,
            depth_or_array_layers: 1,
        },
        TextureDimension::D2,
        &[0, 0, 0, 255],  // Black background
        TextureFormat::Rgba8UnormSrgb,
    );

    let handle = images.add(image);

    commands.insert_resource(TerminalTexture {
        handle,
        width,
        height,
    });
}
```

#### 3.2: Grid Rendering
- [ ] Iterate terminal grid
- [ ] For each cell, blit glyph from atlas
- [ ] Apply foreground/background colors
- [ ] Update texture data

**Code Location:** `bevy-terminal/src/renderer.rs`

```rust
fn render_terminal_grid(
    term_state: Res<TerminalState>,
    atlas: Res<GlyphAtlas>,
    terminal_texture: Res<TerminalTexture>,
    mut images: ResMut<Assets<Image>>,
    colors: Res<TokyoNightColors>,
) {
    let Some(image) = images.get_mut(&terminal_texture.handle) else {
        return;
    };

    let grid = term_state.term.grid();

    for row in 0..term_state.size.rows {
        for col in 0..term_state.size.cols {
            let cell = &grid[row][col];

            // Get glyph from atlas
            let Some(uv) = atlas.uv_map.get(&cell.c) else {
                continue;  // Fallback to space
            };

            // Blit glyph to texture with colors
            blit_glyph(
                &mut image.data,
                &atlas.texture_data,
                atlas.atlas_width,
                terminal_texture.width,
                col * atlas.cell_width,
                row * atlas.cell_height,
                atlas.cell_width,
                atlas.cell_height,
                uv,
                cell.fg,  // Map to Color
                cell.bg,
            );
        }
    }
}
```

#### 3.3: Dirty Region Optimization
- [ ] Track changed cells
- [ ] Only re-render dirty regions
- [ ] Minimize GPU uploads

### Success Criteria
- Terminal grid renders to texture
- Texture updates when terminal changes
- Colors applied correctly (Tokyo Night)
- Performance suitable for 60+ FPS

### Testing
```bash
# Run example, type in terminal
cargo run --example claude_crt

# Should see terminal output in texture
# Type "ls" ‚Üí see file listing
# Type "echo hello" ‚Üí see "hello"
```

### Jujutsu Change
```
feat: Implement render-to-texture terminal rendering

Why: Core rendering system for terminal display
Approach:
- Terminal grid ‚Üí Image texture pixel buffer
- Glyph blitting from atlas with color modulation
- Dirty region tracking for performance
- Expose Handle<Image> via TerminalTexture resource

Status: Complete - terminal renders to texture, updates in real-time

Co-authored-by: Claude <claude@anthropic.com>
```

---

## Phase 4: Game Integration (CRT Character Demo)

**Goal:** Example showing Claude character with tiny CRT head

### Tasks

#### 4.1: Claude Character Sprite
- [ ] Spawn sprite using terminal texture
- [ ] Scale to 0.05 (tiny CRT head)
- [ ] Position in game world
- [ ] Add Interactable component

#### 4.2: Zoom Interaction
- [ ] Detect 'E' key press near character
- [ ] Animate scale from 0.05 ‚Üí 1.0
- [ ] Enable terminal input when zoomed
- [ ] ESC to zoom back out

#### 4.3: Input Routing
- [ ] Only route keyboard to terminal when active
- [ ] Show help text based on state
- [ ] Smooth camera/scale transitions

### Success Criteria
- Claude character shows tiny terminal on CRT head
- Terminal is readable even when tiny
- Smooth zoom transition
- Can type commands when zoomed in
- Terminal persists when zooming out

### Jujutsu Change
```
feat: Add Claude CRT character example with zoom interaction

Why: Demonstrate render-to-texture terminal in game context
Approach:
- Terminal texture as tiny sprite (0.05 scale)
- Zoom to fullscreen on interaction
- Input routing based on state
- Persistent terminal across zoom states

Status: Complete - working CRT character demo

Co-authored-by: Claude <claude@anthropic.com>
```

---

## Timeline Estimate

- **Phase 0:** 1-2 hours (setup, config)
- **Phase 1:** 3-4 hours (PTY, terminal backend)
- **Phase 2:** 2-3 hours (font, atlas)
- **Phase 3:** 3-4 hours (render-to-texture)
- **Phase 4:** 2-3 hours (game integration)

**Total:** ~12-16 hours of focused development

**Actual:** Will vary based on debugging, learning curve

---

## Next Steps After MVP

Once all 4 phases complete:
1. Polish (CRT shader effects, animations)
2. Multiple terminals architecture
3. Font ligatures support
4. Emoji rendering
5. Configuration system
6. Published as crate

---

**Each phase is a milestone.** Test thoroughly before moving to next!
