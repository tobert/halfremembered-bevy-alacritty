Please review the following Rust code for a Bevy terminal emulation plugin. This is Phase 1.1: PTY Spawning.

Context:
- Building a render-to-texture terminal plugin for Bevy 0.17
- This module handles persistent PTY lifecycle management
- Uses portable-pty for cross-platform support
- PTY spawns in Startup system and runs until app shutdown
- Reader/writer wrapped in Arc<Mutex<>> for thread-safety

Please review for:
1. Rust idioms and best practices
2. Error handling patterns (we use anyhow::Result)
3. Thread-safety of the Arc<Mutex<>> approach
4. Potential issues with the non-blocking I/O strategy
5. Cross-platform compatibility (Unix/Windows)
6. Test coverage and quality
7. Any performance considerations
8. Alternative approaches we should consider

Here's the code from bevy-terminal/src/pty.rs:

---FILE START---
//! PTY lifecycle management.
//!
//! PTYs are spawned in Startup system and run persistently.
//! Uses portable-pty for cross-platform PTY spawning.

use anyhow::{Context, Result};
use bevy::prelude::*;
use portable_pty::{native_pty_system, Child, CommandBuilder, PtySize};
use std::io::{Read, Write};
use std::sync::{Arc, Mutex};

/// Resource holding PTY handles for the terminal.
///
/// The PTY runs persistently from Startup until app shutdown.
/// Reader/writer are thread-safe to allow background polling.
#[derive(Resource)]
pub struct PtyResource {
    pub reader: Arc<Mutex<Box<dyn Read + Send>>>,
    pub writer: Arc<Mutex<Box<dyn Write + Send>>>,
    pub child: Box<dyn Child + Send + Sync>,
}

/// Spawns a persistent PTY running the default shell.
///
/// System: Startup
/// Runs: Once at application start
///
/// Configuration (MVP hardcoded):
/// - Size: 120 cols √ó 30 rows
/// - Shell: bash (or platform default)
/// - Non-blocking IO enabled
pub fn spawn_pty(mut commands: Commands) {
    match spawn_pty_internal() {
        Ok(pty_resource) => {
            info!("‚úÖ PTY spawned successfully");
            commands.insert_resource(pty_resource);
        }
        Err(error) => {
            error!("‚ùå Failed to spawn PTY: {:#}", error);
            panic!("Cannot continue without PTY");
        }
    }
}

fn spawn_pty_internal() -> Result<PtyResource> {
    let pty_system = native_pty_system();

    let pty_size = PtySize {
        rows: 30,
        cols: 120,
        pixel_width: 0,
        pixel_height: 0,
    };

    let pair = pty_system
        .openpty(pty_size)
        .context("Failed to create PTY pair")?;

    // Spawn default shell
    // On Unix: bash, zsh, sh (fallback chain)
    // On Windows: powershell or cmd
    #[cfg(unix)]
    let shell_cmd = std::env::var("SHELL").unwrap_or_else(|_| "/bin/bash".to_string());

    #[cfg(windows)]
    let shell_cmd = std::env::var("COMSPEC").unwrap_or_else(|_| "cmd.exe".to_string());

    let mut cmd = CommandBuilder::new(&shell_cmd);
    cmd.env("TERM", "xterm-256color");

    let child = pair
        .slave
        .spawn_command(cmd)
        .context("Failed to spawn shell process")?;

    // Clone reader and take writer
    let reader = pair
        .master
        .try_clone_reader()
        .context("Failed to clone PTY reader")?;

    let writer = pair
        .master
        .take_writer()
        .context("Failed to take PTY writer")?;

    info!("üêö Spawned shell: {}", shell_cmd);

    Ok(PtyResource {
        reader: Arc::new(Mutex::new(Box::new(reader))),
        writer: Arc::new(Mutex::new(Box::new(writer))),
        child,
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pty_spawns() {
        let result = spawn_pty_internal();
        assert!(result.is_ok(), "PTY should spawn successfully");

        let pty = result.unwrap();

        // Verify we can lock reader/writer
        assert!(pty.reader.lock().is_ok(), "Should be able to lock reader");
        assert!(pty.writer.lock().is_ok(), "Should be able to lock writer");

        // Child process should be running
        // Note: We don't check child status here as it might complete quickly
    }

    #[test]
    fn test_pty_io() {
        let pty = spawn_pty_internal().expect("PTY spawn failed");

        // Write a command
        {
            let mut writer = pty.writer.lock().unwrap();
            writer.write_all(b"echo test\n").expect("Write failed");
            writer.flush().expect("Flush failed");
        }

        // Give shell time to process
        std::thread::sleep(std::time::Duration::from_millis(100));

        // Try to read output
        {
            let mut reader = pty.reader.lock().unwrap();
            let mut buf = [0u8; 1024];

            // Read should not panic (may return WouldBlock or data)
            let _ = reader.read(&mut buf);
        }
    }
}
---FILE END---

Additional context:
- This is part of a larger terminal plugin being built incrementally
- Next phase will integrate alacritty_terminal for grid management
- We prioritize correctness and clarity over performance
- Strong types and descriptive names are preferred
- No unwrap() calls in production code (only in tests with expect())

Please provide your review covering the areas listed above. Be direct and specific about any issues or improvements.
