# Terminal Integration for Endgame of SRE - Technical Design

**Generated by:** Claude Sonnet 4.5 in Research Mode
**Date:** November 7, 2025
**Updated by:** Claude (claude-sonnet-4-5-20250929)
**Last Updated:** November 8, 2025

This design document provides comprehensive technical guidance for implementing terminal emulation as a Bevy plugin.

## Architecture Update: Render-to-Texture

**Key Design Decision:** The terminal uses a **render-to-texture** approach where the grid is rendered to a Bevy `Image` texture. This texture can then be used anywhere in the game:
- As a material on 3D meshes (e.g., CRT-shaped character head)
- As a 2D sprite (scaled tiny or fullscreen)
- In UI overlays
- Multiple simultaneous views of the same terminal

**PTY Lifecycle:** PTYs and terminal state are **persistent** - they start at system initialization and run continuously in the background. Opening/closing terminals in-game only affects UI visibility, not the underlying shell processes.

## Project Overview
Porting the "Endgame of SRE" game (originally from 2023 SREcon talk) to Rust/Bevy with embedded terminal capability. When complete, players can interact with in-game computers to access fully functional terminal sessions running real shells, editors (nvim), and tools (Claude Code).

## Technical Architecture

### Core Components
```
┌─────────────────────────────────────────────┐
│     Bevy Game (0.17)                        │
│  ┌──────────────────────────────────────┐   │
│  │  Terminal Texture Renderer           │   │ ← Renders grid to Image
│  │  (Pixel buffer → Handle<Image>)      │   │   (render-to-texture)
│  └──────────┬───────────────────────────┘   │
│             │                                │
│             │ exposes Handle<Image>          │
│             ▼                                │
│  ┌─────────────────────────────────────┐    │
│  │  Game Integration Layer             │    │ ← Your game uses texture
│  │  - Sprite (tiny on CRT head)        │    │   as sprite/material
│  │  - UI overlay (fullscreen)          │    │
│  │  - CRT shader effects               │    │
│  └─────────────────────────────────────┘    │
│                                              │
│  ┌──────────────────────────────────────┐   │
│  │  Terminal State Manager (Persistent) │   │ ← Bevy resource
│  │  (alacritty_terminal::Term)          │   │   Always running
│  └──────────┬───────────────────────────┘   │
│             │                                │
│  ┌──────────▼───────────────────────────┐   │
│  │  PTY Manager (Persistent)            │   │ ← Spawned at startup
│  │  (portable-pty)                      │   │   Runs continuously
│  └──────────────────────────────────────┘   │
└─────────────────────────────────────────────┘
                │
                ▼
        ┌───────────────┐
        │  Shell/Apps   │ ← bash, nvim, Claude Code
        └───────────────┘   (always running in background)
```

### Key Crates
- **`alacritty_terminal`** - Terminal emulation (ANSI/VT sequences, grid management)
- **`portable-pty`** - Cross-platform PTY creation and process spawning
- **`vte`** (via alacritty_terminal) - ANSI escape sequence parsing
- **`bevy` 0.17** - Game engine

## Plugin Architecture

### Terminal as Bevy Plugin
**The terminal system should be implemented as a Bevy plugin** for clean architecture:

```rust
// Plugin definition
pub struct TerminalPlugin {
    pub font_path: String,
    pub font_size: f32,
    pub cols: u16,
    pub rows: u16,
    pub colors: TerminalColorScheme,
}

impl Plugin for TerminalPlugin {
    fn build(&self, app: &mut App) {
        app
            .init_resource::<TerminalState>()
            .init_resource::<GlyphAtlas>()
            .add_systems(Update, (
                terminal_input_system,
                terminal_update_system,
                terminal_render_system,
            ))
            .add_event::<TerminalEvent>();
    }
}

// Usage in game
fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(TerminalPlugin {
            font_path: "fonts/CascadiaMono-Regular.ttf".into(),
            font_size: 12.0,
            cols: 120,
            rows: 30,
            colors: tokyo_night_colors(),
        })
        .run();
}
```

### Plugin Benefits
1. **Clean separation** - Terminal isolated from game logic
2. **Reusable** - Could use in other projects or open-source separately
3. **Idiomatic Bevy** - Follows established patterns
4. **Configurable** - Easy to adjust settings
5. **Testable** - Can test plugin independently

### Plugin Module Structure
```
src/
  lib.rs              # Plugin exports and prelude
  terminal.rs         # Plugin definition and public interface
  pty.rs              # PTY lifecycle management (persistent)
  renderer.rs         # Render-to-texture system (grid → Image)
  font.rs             # Font loading and metrics
  atlas.rs            # Glyph atlas generation
  input.rs            # Keyboard input → PTY
  events.rs           # TerminalEvent types
  colors.rs           # Color scheme definitions (hardcoded)
```

## MVP Scope

Minimal viable implementation:
1. Terminal plugin structure (hardcoded configuration)
2. Load Cascadia Mono font with high-quality rendering
3. Single terminal (render-to-texture)
4. PTY spawns bash shell at startup (persistent)
5. Keyboard input works (when terminal has focus)
6. Render-to-texture with glyph atlas (4096x4096+)
7. Expose `Handle<Image>` for game integration
8. Terminal state persists when UI hidden

Designed for (implement later):
- Multiple concurrent terminals (architecture supports it)
- Font ligatures and emoji
- Runtime configuration
- Scrollback buffer UI
- Copy/paste
- Dynamic terminal resizing
- Plugin as separate crate/publishable package

## Font Rendering for Terminal

### Font Selection
**Primary Recommendation: Cascadia Mono** - Microsoft's terminal font with excellent hinting, designed for ClearType. Use NF (Nerd Font) variant for powerline/icon support.

**Alternatives:** JetBrains Mono, Fira Mono, or Iosevka Term

**Requirements:** Monospace with clear distinction between 0/O, 1/l/I and good Unicode coverage for box-drawing characters.

### Font Rendering Configuration

- **Font Size**: 12-14pt typical (Bevy handles DPI scaling)
- **Hinting**: FreeType (enabled by default) - aligns glyphs to pixel grid
- **Anti-aliasing**: Grayscale enabled by default
- **Cell Dimensions**: Must be exactly consistent across all characters
  - `cell_width`: Use font's advance width metric
  - `cell_height`: ascent + descent + line_gap

### Glyph Atlas Strategy

**Pre-rendered Glyph Atlas (Recommended)** - Crisp rendering with proper hinting, fast updates. Pre-render ASCII (32-126), box-drawing (U+2500-U+257F), and block elements (U+2580-U+259F) to texture atlas. Render extended Unicode on-demand.

```rust
struct GlyphAtlas {
    texture: Handle<Image>,
    glyph_uvs: HashMap<char, Rect>,
    cell_width: f32,
    cell_height: f32,
}
```

### Color and Effects

**From Tokyo Night Theme (Reference Config):**
```rust
struct TerminalColors {
    // Background
    bg: Color::hex("#16161e"),
    fg: Color::hex("#c0caf5"),
    
    // Standard colors (0-7)
    black: Color::hex("#15161e"),
    red: Color::hex("#f7768e"),
    green: Color::hex("#9ece6a"),
    yellow: Color::hex("#e0af68"),
    blue: Color::hex("#7aa2f7"),
    magenta: Color::hex("#bb9af7"),
    cyan: Color::hex("#7dcfff"),
    white: Color::hex("#a9b1d6"),
    
    // Bright colors (8-15)
    bright_black: Color::hex("#414868"),
    bright_red: Color::hex("#f7768e"),
    bright_green: Color::hex("#9ece6a"),
    bright_yellow: Color::hex("#e0af68"),
    bright_blue: Color::hex("#7aa2f7"),
    bright_magenta: Color::hex("#bb9af7"),
    bright_cyan: Color::hex("#7dcfff"),
    bright_white: Color::hex("#c0caf5"),
}
```

**Text Effects from Terminal:**
- Bold: Use bold font variant OR increase brightness
- Italic: Use italic font variant
- Underline: Draw line below baseline
- Strikethrough: Draw line at middle height
- Dim: Reduce opacity/brightness

### Platform-Specific Considerations

**Windows:**
- ClearType sub-pixel rendering expected
- Cascadia fonts optimized for Windows
- Consider DirectWrite font rendering settings

**Linux:**
- FreeType hinting (autohint or native)
- fontconfig for font fallback
- May need to bundle fonts

**macOS:**
- Core Text handles font rendering
- Generally good default hinting
- SF Mono also a good option

## Implementation Strategy

### Phase 1: Terminal Backend
1. Create plugin structure with basic scaffolding
2. Integrate `alacritty_terminal::Term` as a Bevy resource
3. Use `portable-pty` to create PTY and spawn shell
4. Poll PTY for output, feed bytes to `Term`
5. Handle input: capture keyboard events, write to PTY

### Phase 2: Font Loading & Glyph Atlas
1. Load monospace font (Cascadia Code/Mono recommended)
2. Measure font metrics (cell_width, cell_height)
3. Pre-render ASCII + box-drawing chars to texture atlas
4. Build UV mapping for quick glyph lookup
5. Test with static text rendering first

### Phase 3: Terminal Rendering (Render-to-Texture)
**Approach: Render grid to Image texture**
- Create `Image` with dimensions `(cols * cell_width, rows * cell_height)` pixels
- For each cell in terminal grid, rasterize glyph to pixel buffer
- Upload pixel buffer to GPU texture
- Expose `Handle<Image>` via resource for game use
- Update only changed regions for performance

```rust
// Pseudo-code for render-to-texture
fn render_terminal_to_texture(
    term: &Term,
    atlas: &GlyphAtlas,
    texture: &mut Image,
) {
    let pixel_buffer = &mut texture.data;

    for row in 0..term.rows() {
        for col in 0..term.cols() {
            let cell = term.grid()[row][col];

            // Get glyph pixels from atlas
            let glyph_pixels = atlas.get_glyph_pixels(cell.c);

            // Blit to texture at (col * cell_width, row * cell_height)
            blit_with_colors(
                pixel_buffer,
                glyph_pixels,
                col * cell_width,
                row * cell_height,
                cell.fg,
                cell.bg,
            );
        }
    }
}

// Game accesses texture via resource
#[derive(Resource)]
pub struct TerminalTexture {
    pub handle: Handle<Image>,
    pub width: u32,
    pub height: u32,
}
```

### Phase 4: Game Integration
**Using the Terminal Texture in Your Game:**

```rust
// In your game (e.g., ~/src/sregame)
use bevy_terminal::prelude::*;

fn spawn_claude_character(
    mut commands: Commands,
    terminal_texture: Res<TerminalTexture>,
) {
    // Tiny sprite on CRT character head
    commands.spawn((
        Sprite::from_image(terminal_texture.handle.clone()),
        Transform::from_xyz(100.0, 200.0, 0.0)
            .with_scale(Vec3::splat(0.05)), // Very tiny
        ClaudeCharacter,
        Interactable,
    ));
}

fn zoom_to_terminal(
    interaction: Query<&Interaction, With<ClaudeCharacter>>,
    mut sprite: Query<&mut Transform, With<TerminalSprite>>,
) {
    if interaction.single().is_pressed() {
        // Smooth zoom: scale from 0.05 to 1.0
        sprite.single_mut().scale = Vec3::splat(1.0);
    }
}
```

**Rendering States:**
1. **Background** - PTY/Term updating, no texture rendering
2. **Minimized** - Render to texture, display tiny on CRT head sprite
3. **Fullscreen** - Render to texture, display as UI overlay (zoomed)

**Multiple Terminals:**
- Each terminal = separate `Handle<Image>` + PTY + Term
- Can show multiple simultaneously (e.g., different characters)
- Architecture supports it; MVP implements one

## Critical Technical Details

### Terminal Grid Access
```rust
// Access terminal grid for rendering
let grid = term.grid();
for row in grid.display_iter() {
    for cell in row {
        // cell.c: char
        // cell.fg: Color
        // cell.bg: Color  
        // cell.flags: CellFlags (bold, italic, etc.)
    }
}
```

### PTY Lifecycle
```rust
// Create PTY
let pty_system = native_pty_system();
let pair = pty_system.openpty(PtySize {
    rows: 30,
    cols: 120,
    pixel_width: 0,
    pixel_height: 0,
})?;

// Spawn shell/program
let cmd = CommandBuilder::new("bash"); // or "nvim", "claude-code"
let child = pair.slave.spawn_command(cmd)?;

// Read from master (non-blocking recommended)
let mut reader = pair.master.try_clone_reader()?;
// Write input to master
let mut writer = pair.master.take_writer()?;
```

### Input Handling in Bevy
- Capture `KeyCode` events from Bevy's input system
- Convert to appropriate byte sequences for PTY
- Handle special keys (arrows, function keys, etc.) as ANSI sequences
- Don't forget Ctrl+key combinations

### Terminal Configuration
Reference colors and dimensions from provided Alacritty config:
- Default size: 120 cols × 30 rows
- Font: Cascadia Code NF (or fallback to system monospace)
- Tokyo Night color scheme (dark background #16161e)
- Support 256 colors + true color

## Performance Considerations

**Render-to-Texture Optimizations:**
- **Incremental updates**: Only re-render changed cells to texture
- **Dirty region tracking**: Blit only modified portions of texture
- **GPU upload optimization**: Minimize texture updates per frame
- **Atlas caching**: Large pre-rendered glyph atlas (4096x4096+) in VRAM

**Update Strategy:**
- **High refresh rate**: 60-120 Hz for smooth rendering (live demo quality)
- **PTY polling**: Use Bevy's async task pool → Alacritty patterns → Tokio fallback
- **Continuous updates**: Terminal state updates even when UI hidden (persistent PTY)
- **Background processing**: PTY I/O on separate task, grid updates on main thread

**Memory Strategy (Quality Over Constraints):**
- **Large atlas**: Use VRAM generously for crisp rendering
- **Multiple terminals**: Each has own texture, all share atlas
- **Persistent state**: Terminals run 24/7 in background (game concept)

**Texture Management:**
- Consider `TextureFormat::Rgba8UnormSrgb` for color accuracy
- Texture size: `(120 cols * ~10px) x (30 rows * ~20px)` = ~1200x600 base
- Scale as needed for quality (2x or 4x for retina/high-DPI)

## Testing Approach
1. **Font rendering test**: Render static grid of all ASCII chars
2. **Font metrics verification**: Ensure perfect alignment
3. **Plugin integration**: Verify plugin loads and initializes correctly
4. Static terminal showing shell prompt
5. Verify keyboard input echoes correctly
6. Test with simple commands (`ls`, `echo`)
7. Progress to interactive apps (nvim, top)
8. Add Claude Code integration
9. Implement multiple terminal instances

## Platform Notes
- **Windows**: PTY support via ConPTY (Windows 10+)
- **Linux/macOS**: Standard Unix PTY
- `portable-pty` abstracts platform differences
- Test on target platform early
- **Font paths**: Bundle fonts or use system font discovery

## Font Asset Structure
```
assets/
  fonts/
    CascadiaMono-Regular.ttf
    CascadiaMono-Bold.ttf
    CascadiaMono-Italic.ttf
    CascadiaMono-BoldItalic.ttf
    # Or use NF variants for icon support:
    CascadiaMonoNF-Regular.ttf
    # Narrow variant alternative:
    CascadiaCodeNF-SemiLight.ttf
```

## Main Game Integration

### Plugin Setup (main.rs)
```rust
use bevy::prelude::*;
use bevy_terminal::prelude::*;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(TerminalPlugin) // Hardcoded config for MVP
        .add_systems(Startup, spawn_claude_character)
        .add_systems(Update, handle_terminal_interaction)
        .run();
}
```

### Using Terminal Texture in Game
```rust
fn spawn_claude_character(
    mut commands: Commands,
    terminal_texture: Res<TerminalTexture>,
    asset_server: Res<AssetServer>,
) {
    // Claude character with CRT head showing real terminal
    commands.spawn((
        Sprite::from_image(terminal_texture.handle.clone()),
        Transform::from_xyz(100.0, 200.0, 10.0) // Z for layering
            .with_scale(Vec3::splat(0.05)), // Tiny CRT head
        ClaudeCharacter,
        Interactable { range: 50.0 },
    ));
}

fn handle_terminal_interaction(
    keyboard: Res<ButtonInput<KeyCode>>,
    interaction: Query<&Interaction, With<ClaudeCharacter>>,
    mut terminal_view: Query<&mut Transform, With<TerminalSprite>>,
    mut input_mode: ResMut<TerminalInputMode>,
) {
    // Zoom in when player presses 'E' near Claude
    if keyboard.just_pressed(KeyCode::KeyE) {
        if let Ok(interaction) = interaction.get_single() {
            if *interaction == Interaction::Hovered {
                // Animate scale from 0.05 → 1.0
                terminal_view.single_mut().scale = Vec3::splat(1.0);
                *input_mode = TerminalInputMode::Active;
            }
        }
    }

    // ESC to zoom out
    if keyboard.just_pressed(KeyCode::Escape) {
        terminal_view.single_mut().scale = Vec3::splat(0.05);
        *input_mode = TerminalInputMode::Inactive;
    }
}
```

## References
- Bevy 0.17 docs: https://bevyengine.org/
- Bevy 0.17 release notes: https://bevyengine.org/news/bevy-0-17/
- alacritty_terminal source: https://github.com/alacritty/alacritty (use as reference)
- portable-pty: https://docs.rs/portable-pty/
- Cascadia Code: https://github.com/microsoft/cascadia-code
- Font rendering in Bevy: https://bevyengine.org/examples/UI/text/
- Bevy Plugin Guide: https://bevyengine.org/learn/book/plugin-development/

## Success Criteria
When complete, player should be able to:
1. Walk to in-game computer sprite
2. Press interaction key (e.g., 'E')
3. Terminal appears with crisp, readable text
4. Type commands, run programs (nvim, Claude Code)
5. Exit terminal back to game
6. Terminal state persists across open/close cycles
7. Text rendering is sharp and properly hinted at default size
8. Plugin is cleanly separated and could be extracted to separate crate

## Additional Notes

### Why Alacritty Terminal?
- Battle-tested terminal emulator backend
- Excellent ANSI/VT sequence support
- Well-documented grid structure
- Active maintenance
- Used by actual Alacritty terminal (dogfooding)

### Why Render-to-Texture?
- **Single draw call** - Entire terminal is one sprite/quad
- **Flexible display** - Same texture used tiny (CRT head) or fullscreen
- **Simple integration** - Game just uses `Handle<Image>`
- **Multiple views** - Can show same terminal in different places
- **Shader effects** - Easy to apply CRT scanlines, phosphor glow
- **Decoupled lifecycle** - Terminal updates independent of display
- **Proven approach** - How many terminal emulators work internally

### Tmux Integration Note
Since you mentioned tmux: you can run tmux inside the terminal for multiple panes/windows. The terminal emulator just needs to handle one PTY that happens to be running tmux. This is simpler than managing multiple Term instances initially.

---

**Implementation Philosophy**: 
- Start with plugin skeleton and basic font rendering
- Get PTY working with simple echo test
- Wire up rendering incrementally
- Only optimize after basic functionality works
- Keep plugin interface clean for potential open-source release

**For Claude Code**: Focus on one phase at a time. Get the plugin structure right first, then tackle PTY integration, then rendering. Each phase should have working code before moving to the next.
