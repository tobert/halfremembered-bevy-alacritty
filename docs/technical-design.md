# Terminal Integration for Endgame of SRE - Technical Design

**Generated by:** Claude Sonnet 4.5 in Research Mode
**Date:** November 7, 2025

This design document provides comprehensive technical guidance for implementing terminal emulation as a Bevy plugin.

## Project Overview
Porting the "Endgame of SRE" game (originally from 2023 SREcon talk) to Rust/Bevy with embedded terminal capability. When complete, players can interact with in-game computers to access fully functional terminal sessions running real shells, editors (nvim), and tools (Claude Code).

## Technical Architecture

### Core Components
```
┌─────────────────────────────────┐
│     Bevy Game (0.17)            │
│  ┌──────────────────────────┐   │
│  │  Terminal Renderer       │   │ ← Renders grid to screen
│  │  (Bevy UI/Sprites)       │   │
│  └──────────┬───────────────┘   │
│             │                    │
│  ┌──────────▼───────────────┐   │
│  │  Terminal State Manager  │   │ ← Bevy resource/system
│  │  (alacritty_terminal)    │   │
│  └──────────┬───────────────┘   │
│             │                    │
│  ┌──────────▼───────────────┐   │
│  │  PTY Manager             │   │ ← Spawns/manages processes
│  │  (portable-pty)          │   │
│  └──────────────────────────┘   │
└─────────────────────────────────┘
                │
                ▼
        ┌───────────────┐
        │  Shell/Apps   │ ← bash, nvim, Claude Code
        └───────────────┘
```

### Key Crates
- **`alacritty_terminal`** - Terminal emulation (ANSI/VT sequences, grid management)
- **`portable-pty`** - Cross-platform PTY creation and process spawning
- **`vte`** (via alacritty_terminal) - ANSI escape sequence parsing
- **`bevy` 0.17** - Game engine

## Plugin Architecture

### Terminal as Bevy Plugin
**The terminal system should be implemented as a Bevy plugin** for clean architecture:

```rust
// Plugin definition
pub struct TerminalPlugin {
    pub font_path: String,
    pub font_size: f32,
    pub cols: u16,
    pub rows: u16,
    pub colors: TerminalColorScheme,
}

impl Plugin for TerminalPlugin {
    fn build(&self, app: &mut App) {
        app
            .init_resource::<TerminalState>()
            .init_resource::<GlyphAtlas>()
            .add_systems(Update, (
                terminal_input_system,
                terminal_update_system,
                terminal_render_system,
            ))
            .add_event::<TerminalEvent>();
    }
}

// Usage in game
fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(TerminalPlugin {
            font_path: "fonts/CascadiaMono-Regular.ttf".into(),
            font_size: 12.0,
            cols: 120,
            rows: 30,
            colors: tokyo_night_colors(),
        })
        .run();
}
```

### Plugin Benefits
1. **Clean separation** - Terminal isolated from game logic
2. **Reusable** - Could use in other projects or open-source separately
3. **Idiomatic Bevy** - Follows established patterns
4. **Configurable** - Easy to adjust settings
5. **Testable** - Can test plugin independently

### Plugin Module Structure
```
src/
  terminal.rs         # Plugin definition and public interface
  terminal/
    state.rs         # Terminal state resource
    pty.rs           # PTY lifecycle management
    renderer.rs      # Terminal grid rendering system
    font.rs          # Font loading and metrics
    atlas.rs         # Glyph atlas generation
    input.rs         # Keyboard input → PTY
    events.rs        # TerminalEvent types
    colors.rs        # Color scheme definitions
```

## MVP Scope

Minimal viable implementation:
1. Terminal plugin structure with configuration
2. Load monospace font with good hinting
3. Single terminal overlay (fullscreen or large window)
4. Spawns bash shell
5. Keyboard input works
6. Basic sprite-based rendering with glyph atlas
7. Can exit terminal back to game

Defer for later:
- Multiple concurrent terminals
- Font size adjustment at runtime
- Advanced rendering (ligatures, emoji wide chars)
- Scrollback buffer UI
- Copy/paste
- Terminal resizing
- Plugin as separate crate/publishable package

## Font Rendering for Terminal

### Font Selection
**Primary Recommendation: Cascadia Mono** - Microsoft's terminal font with excellent hinting, designed for ClearType. Use NF (Nerd Font) variant for powerline/icon support.

**Alternatives:** JetBrains Mono, Fira Mono, or Iosevka Term

**Requirements:** Monospace with clear distinction between 0/O, 1/l/I and good Unicode coverage for box-drawing characters.

### Font Rendering Configuration

- **Font Size**: 12-14pt typical (Bevy handles DPI scaling)
- **Hinting**: FreeType (enabled by default) - aligns glyphs to pixel grid
- **Anti-aliasing**: Grayscale enabled by default
- **Cell Dimensions**: Must be exactly consistent across all characters
  - `cell_width`: Use font's advance width metric
  - `cell_height`: ascent + descent + line_gap

### Glyph Atlas Strategy

**Pre-rendered Glyph Atlas (Recommended)** - Crisp rendering with proper hinting, fast updates. Pre-render ASCII (32-126), box-drawing (U+2500-U+257F), and block elements (U+2580-U+259F) to texture atlas. Render extended Unicode on-demand.

```rust
struct GlyphAtlas {
    texture: Handle<Image>,
    glyph_uvs: HashMap<char, Rect>,
    cell_width: f32,
    cell_height: f32,
}
```

### Color and Effects

**From Tokyo Night Theme (Reference Config):**
```rust
struct TerminalColors {
    // Background
    bg: Color::hex("#16161e"),
    fg: Color::hex("#c0caf5"),
    
    // Standard colors (0-7)
    black: Color::hex("#15161e"),
    red: Color::hex("#f7768e"),
    green: Color::hex("#9ece6a"),
    yellow: Color::hex("#e0af68"),
    blue: Color::hex("#7aa2f7"),
    magenta: Color::hex("#bb9af7"),
    cyan: Color::hex("#7dcfff"),
    white: Color::hex("#a9b1d6"),
    
    // Bright colors (8-15)
    bright_black: Color::hex("#414868"),
    bright_red: Color::hex("#f7768e"),
    bright_green: Color::hex("#9ece6a"),
    bright_yellow: Color::hex("#e0af68"),
    bright_blue: Color::hex("#7aa2f7"),
    bright_magenta: Color::hex("#bb9af7"),
    bright_cyan: Color::hex("#7dcfff"),
    bright_white: Color::hex("#c0caf5"),
}
```

**Text Effects from Terminal:**
- Bold: Use bold font variant OR increase brightness
- Italic: Use italic font variant
- Underline: Draw line below baseline
- Strikethrough: Draw line at middle height
- Dim: Reduce opacity/brightness

### Platform-Specific Considerations

**Windows:**
- ClearType sub-pixel rendering expected
- Cascadia fonts optimized for Windows
- Consider DirectWrite font rendering settings

**Linux:**
- FreeType hinting (autohint or native)
- fontconfig for font fallback
- May need to bundle fonts

**macOS:**
- Core Text handles font rendering
- Generally good default hinting
- SF Mono also a good option

## Implementation Strategy

### Phase 1: Terminal Backend
1. Create plugin structure with basic scaffolding
2. Integrate `alacritty_terminal::Term` as a Bevy resource
3. Use `portable-pty` to create PTY and spawn shell
4. Poll PTY for output, feed bytes to `Term`
5. Handle input: capture keyboard events, write to PTY

### Phase 2: Font Loading & Glyph Atlas
1. Load monospace font (Cascadia Code/Mono recommended)
2. Measure font metrics (cell_width, cell_height)
3. Pre-render ASCII + box-drawing chars to texture atlas
4. Build UV mapping for quick glyph lookup
5. Test with static text rendering first

### Phase 3: Terminal Rendering
**Recommended: Sprite-Based Approach**
- Each terminal cell = sprite entity
- Position: `(col * cell_width, row * cell_height)`
- Sprite: glyph from atlas with UV coords
- Color: modulate sprite color for fg/bg
- Update only changed cells per frame

```rust
// Pseudo-code
for (row, col, changed) in term.changed_cells() {
    let cell = term.grid()[row][col];
    
    // Update sprite component
    sprite.index = glyph_atlas.get_index(cell.c);
    sprite.color = cell.fg;
    background.color = cell.bg;
    
    // Handle bold/italic via material variants
    if cell.flags.contains(CellFlags::BOLD) {
        sprite.material = bold_material;
    }
}
```

### Phase 4: Game Integration
- Trigger terminal overlay when player interacts with computer sprite
- Pause/unpause game when terminal active
- ESC or specific key combo to close terminal
- Support multiple terminal sessions (tmux pattern internally or multiple Term instances)

## Critical Technical Details

### Terminal Grid Access
```rust
// Access terminal grid for rendering
let grid = term.grid();
for row in grid.display_iter() {
    for cell in row {
        // cell.c: char
        // cell.fg: Color
        // cell.bg: Color  
        // cell.flags: CellFlags (bold, italic, etc.)
    }
}
```

### PTY Lifecycle
```rust
// Create PTY
let pty_system = native_pty_system();
let pair = pty_system.openpty(PtySize {
    rows: 30,
    cols: 120,
    pixel_width: 0,
    pixel_height: 0,
})?;

// Spawn shell/program
let cmd = CommandBuilder::new("bash"); // or "nvim", "claude-code"
let child = pair.slave.spawn_command(cmd)?;

// Read from master (non-blocking recommended)
let mut reader = pair.master.try_clone_reader()?;
// Write input to master
let mut writer = pair.master.take_writer()?;
```

### Input Handling in Bevy
- Capture `KeyCode` events from Bevy's input system
- Convert to appropriate byte sequences for PTY
- Handle special keys (arrows, function keys, etc.) as ANSI sequences
- Don't forget Ctrl+key combinations

### Terminal Configuration
Reference colors and dimensions from provided Alacritty config:
- Default size: 120 cols × 30 rows
- Font: Cascadia Code NF (or fallback to system monospace)
- Tokyo Night color scheme (dark background #16161e)
- Support 256 colors + true color

## Performance Considerations
- **Incremental rendering**: Only update changed cells, not full grid
- **Event polling**: Use Bevy's `FixedUpdate` or manual scheduling for PTY reads
- **Double buffering**: Consider alternating grids to detect changes
- **Async I/O**: PTY reads should be non-blocking; consider `tokio` integration if needed
- **Glyph atlas caching**: Pre-render common chars, lazy-load rare Unicode
- **Sprite pooling**: Reuse sprite entities rather than spawn/despawn

## Testing Approach
1. **Font rendering test**: Render static grid of all ASCII chars
2. **Font metrics verification**: Ensure perfect alignment
3. **Plugin integration**: Verify plugin loads and initializes correctly
4. Static terminal showing shell prompt
5. Verify keyboard input echoes correctly
6. Test with simple commands (`ls`, `echo`)
7. Progress to interactive apps (nvim, top)
8. Add Claude Code integration
9. Implement multiple terminal instances

## Platform Notes
- **Windows**: PTY support via ConPTY (Windows 10+)
- **Linux/macOS**: Standard Unix PTY
- `portable-pty` abstracts platform differences
- Test on target platform early
- **Font paths**: Bundle fonts or use system font discovery

## Font Asset Structure
```
assets/
  fonts/
    CascadiaMono-Regular.ttf
    CascadiaMono-Bold.ttf
    CascadiaMono-Italic.ttf
    CascadiaMono-BoldItalic.ttf
    # Or use NF variants for icon support:
    CascadiaMonoNF-Regular.ttf
    # Narrow variant alternative:
    CascadiaCodeNF-SemiLight.ttf
```

## Main Game Integration
```rust
// In main.rs or game module
use terminal::TerminalPlugin;

fn setup_game(mut commands: Commands) {
    // Spawn terminal when player interacts with computer
    commands.spawn(TerminalBundle {
        // ...
    });
}
```

## References
- Bevy 0.17 docs: https://bevyengine.org/
- Bevy 0.17 release notes: https://bevyengine.org/news/bevy-0-17/
- alacritty_terminal source: https://github.com/alacritty/alacritty (use as reference)
- portable-pty: https://docs.rs/portable-pty/
- Cascadia Code: https://github.com/microsoft/cascadia-code
- Font rendering in Bevy: https://bevyengine.org/examples/UI/text/
- Bevy Plugin Guide: https://bevyengine.org/learn/book/plugin-development/

## Success Criteria
When complete, player should be able to:
1. Walk to in-game computer sprite
2. Press interaction key (e.g., 'E')
3. Terminal appears with crisp, readable text
4. Type commands, run programs (nvim, Claude Code)
5. Exit terminal back to game
6. Terminal state persists across open/close cycles
7. Text rendering is sharp and properly hinted at default size
8. Plugin is cleanly separated and could be extracted to separate crate

## Additional Notes

### Why Alacritty Terminal?
- Battle-tested terminal emulator backend
- Excellent ANSI/VT sequence support
- Well-documented grid structure
- Active maintenance
- Used by actual Alacritty terminal (dogfooding)

### Why Sprite-Based Rendering?
- Precise control over glyph positioning
- Efficient updates (change sprite index, not rebuild text)
- Consistent with game rendering pipeline
- Can apply effects (shaders, etc.) easily
- Proven approach (this is how real terminals work)

### Tmux Integration Note
Since you mentioned tmux: you can run tmux inside the terminal for multiple panes/windows. The terminal emulator just needs to handle one PTY that happens to be running tmux. This is simpler than managing multiple Term instances initially.

---

**Implementation Philosophy**: 
- Start with plugin skeleton and basic font rendering
- Get PTY working with simple echo test
- Wire up rendering incrementally
- Only optimize after basic functionality works
- Keep plugin interface clean for potential open-source release

**For Claude Code**: Focus on one phase at a time. Get the plugin structure right first, then tackle PTY integration, then rendering. Each phase should have working code before moving to the next.
